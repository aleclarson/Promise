// Generated by CoffeeScript 1.12.4
var FULFILLED, PENDING, Promise, PromiseTracer, PureObject, REJECTED, StubTracer, Type, assertType, bind, emptyFunction, has, hasKeys, immediate, isDev, isType, sync, type;

emptyFunction = require("emptyFunction");

PureObject = require("PureObject");

assertType = require("assertType");

immediate = require("immediate");

hasKeys = require("hasKeys");

isType = require("isType");

isDev = require("isDev");

Type = require("Type");

sync = require("sync");

bind = require("bind");

has = require("has");

StubTracer = {
  trace: emptyFunction
};

if (isDev) {
  PromiseTracer = require("./PromiseTracer");
}

PENDING = Symbol("Promise.PENDING");

FULFILLED = Symbol("Promise.FULFILLED");

REJECTED = Symbol("Promise.REJECTED");

type = Type("Promise");

type.defineGetters({
  state: function() {
    if (this.isFulfilled) {
      return "fulfilled";
    } else if (this.isRejected) {
      return "rejected";
    } else {
      return "pending";
    }
  },
  isPending: function() {
    return this._state === PENDING;
  },
  isFulfilled: function() {
    return this._state === FULFILLED;
  },
  isRejected: function() {
    return this._state === REJECTED;
  }
});

type.defineMethods({
  inspect: function() {
    var promise;
    promise = {
      state: this.state
    };
    if (this.isFulfilled) {
      promise.value = this._results[0];
    } else if (this.isRejected) {
      promise.error = this._results[0];
    }
    if (this._results.length > 1) {
      promise.meta = this._results.slice(1);
    }
    return promise;
  },
  trace: function() {
    isDev && PromiseTracer().trace(this);
    return this;
  },
  then: function(onFulfilled, onRejected) {
    var promise;
    assertType(onFulfilled, Function.Maybe);
    assertType(onRejected, Function.Maybe);
    promise = Promise(PENDING);
    this._then(promise, onFulfilled, onRejected);
    return promise;
  },
  "catch": function(onRejected) {
    return this.fail(onRejected);
  },
  fail: function(onRejected) {
    var promise;
    assertType(onRejected, Function.Maybe);
    promise = Promise(PENDING);
    this._then(promise, void 0, onRejected);
    return promise;
  },
  "finally": function(onResolved) {
    return this.always(onResolved);
  },
  always: function(onResolved) {
    var promise;
    assertType(onResolved, Function);
    promise = Promise(PENDING);
    this._tracer.trace(promise, this);
    this._always(function(parent) {
      var error, value;
      try {
        value = onResolved();
      } catch (error1) {
        error = error1;
        promise._reject(error);
        return;
      }
      if (isType(value, Promise)) {
        return value._always(function() {
          if (value.isRejected) {
            return promise._reject(value._results[0]);
          } else {
            promise._inherit(parent._results, 1);
            return promise._resolve(parent);
          }
        });
      }
      promise._inherit(parent._results, 1);
      return promise._resolve(parent);
    });
    return promise;
  },
  done: function(onFulfilled, onRejected) {
    if (arguments.length) {
      this.then(onFulfilled, onRejected);
    }
  },
  notify: function(callback) {
    var promise;
    if (!callback) {
      return this;
    }
    assertType(callback, Function);
    promise = Promise(PENDING);
    this._tracer.trace(promise, this);
    this._always(function(parent) {
      var callbackError, error, result;
      promise._inherit(parent._results, 1);
      if (parent.isRejected) {
        error = parent._results[0];
      } else if (parent.isFulfilled) {
        result = parent._results[0];
      }
      try {
        callback(error, result);
        return promise._resolve(parent);
      } catch (error1) {
        callbackError = error1;
        return promise._reject(callbackError);
      }
    });
    return promise;
  },
  assert: function(reason, predicate) {
    var promise;
    assertType(reason, String);
    assertType(predicate, Function.Maybe);
    promise = Promise(PENDING);
    if (predicate == null) {
      predicate = emptyFunction.thatReturnsArgument;
    }
    this._then(promise, function(result) {
      if (!predicate(result)) {
        throw Error(reason);
      }
      return result;
    });
    return promise;
  },
  delay: function(delay) {
    var promise;
    assertType(delay, Number);
    promise = Promise(PENDING);
    this._tracer.trace(promise, this);
    this._always(function(parent) {
      var resolve;
      resolve = function() {
        promise._inherit(parent._results, 1);
        return promise._resolve(parent);
      };
      return setTimeout(resolve, delay);
    });
    return promise;
  },
  timeout: function(delay, callback) {
    var onTimeout, promise, timeout;
    assertType(delay, Number);
    assertType(callback, Function);
    promise = Promise(PENDING);
    this._tracer.trace(promise, this);
    if (!this.isPending) {
      immediate(this, function() {
        promise._inherit(this._results, 1);
        return promise._resolve(this);
      });
      return promise;
    }
    onTimeout = function() {
      var error, result, timeout;
      timeout = null;
      try {
        result = callback();
      } catch (error1) {
        error = error1;
        promise._reject(error);
        return;
      }
      promise._fulfill(result);
    };
    timeout = setTimeout(onTimeout, delay);
    this._queue.push(function(parent) {
      if (timeout !== null) {
        clearTimeout(timeout);
        promise._inherit(parent._results, 1);
        promise._resolve(parent);
      }
    });
    return promise;
  }
});

type.defineStatics({
  isFulfilled: function(value) {
    if (!isType(value, Promise)) {
      return false;
    }
    return value.isFulfilled;
  },
  isRejected: function(value) {
    if (!isType(value, Promise)) {
      return true;
    }
    return value.isRejected;
  },
  isPending: function(value) {
    if (!isType(value, Promise)) {
      return false;
    }
    return value.isPending;
  },
  defer: function(resolver) {
    var promise;
    assertType(resolver, Function.Maybe);
    promise = Promise(PENDING);
    if (resolver) {
      return promise._defer(resolver);
    }
    return {
      promise: promise,
      resolve: bind.method(promise, "_tryFulfilling"),
      reject: bind.method(promise, "_reject")
    };
  },
  resolve: function(value) {
    var promise;
    promise = Promise(PENDING);
    promise._inherit(arguments, 1);
    promise._tryFulfilling(value);
    return promise;
  },
  reject: function(error) {
    var promise;
    assertType(error, Error.Kind);
    promise = Promise(PENDING);
    promise._inherit(arguments, 1);
    promise._reject(error);
    return promise;
  },
  "try": function(func) {
    var promise;
    assertType(func, Function);
    promise = Promise(PENDING);
    promise._tryResolving(func);
    return promise;
  },
  delay: function(delay) {
    var fulfill, promise;
    assertType(delay, Number);
    promise = Promise(PENDING);
    fulfill = bind.method(promise, "_fulfill");
    setTimeout(fulfill, delay);
    return promise;
  },
  wrap: function(func) {
    assertType(func, Function);
    return function() {
      var promise;
      promise = Promise(PENDING);
      promise._tryResolving(bind.func(func, this, arguments));
      return promise;
    };
  },
  denodeify: function(func) {
    return this.ify(func);
  },
  ify: function(func) {
    assertType(func, Function);
    return function() {
      var args, promise, self;
      self = this;
      args = arguments;
      promise = Promise(PENDING);
      return promise._defer(function(resolve, reject) {
        Array.prototype.push.call(args, function(error, result) {
          if (error) {
            return reject(error);
          } else {
            return resolve(result);
          }
        });
        return func.apply(self, args);
      });
    };
  },
  all: function(iterable, iterator) {
    var fulfill, promise, reject, remaining, results;
    assertType(iterator, Function.Maybe);
    promise = Promise(PENDING);
    results = Array.isArray(iterable) ? new Array(iterable.length) : PureObject.test(iterable) ? Object.create(null) : {};
    if (!hasKeys(iterable)) {
      immediate(function() {
        return promise._fulfill(results);
      });
      return promise;
    }
    reject = bind.method(promise, "_reject");
    fulfill = function(result, key) {
      if (has(results, key)) {
        return;
      }
      results[key] = result;
      remaining -= 1;
      if (remaining === 0) {
        promise._fulfill(results);
      }
    };
    remaining = 0;
    immediate(function() {
      var tracer;
      tracer = promise._tracer;
      return sync.each(iterable, function(value, key) {
        var pending;
        remaining += 1;
        pending = iterator ? Promise(PENDING, key) : Promise.resolve(value, key);
        tracer.trace(pending, promise);
        pending.then(fulfill, reject);
        if (iterator) {
          pending._tryResolving(iterator, [value, key]);
        }
      });
    });
    return promise;
  },
  map: function(iterable, iterator) {
    console.warn("Promise.map() is deprecated! Use Promise.all() instead!");
    return this.all(iterable, iterator);
  },
  chain: function(iterable, iterator) {
    assertType(iterator, Function);
    return sync.reduce(iterable, Promise.resolve(), function(chain, value, key) {
      return chain.then(function() {
        return iterator.call(null, value, key);
      });
    });
  },
  race: function(array) {
    var deferred, i, len, promise;
    assertType(array, Array);
    deferred = Promise.defer();
    for (i = 0, len = array.length; i < len; i++) {
      promise = array[i];
      if (promise && promise.then) {
        promise.then(deferred.resolve, deferred.reject);
      }
    }
    return deferred.promise;
  },
  onUnhandledRejection: function(fallback) {
    this._rejectFallbacks.push(fallback);
  }
});

type.defineValues(function() {
  return {
    _state: PENDING,
    _unhandled: true,
    _results: [void 0],
    _queue: [],
    _tracer: StubTracer
  };
});

type.initInstance(function(result) {
  if (result === PENDING) {
    this._inherit(arguments, 1);
    return;
  }
  this._defer(result);
});

type.defineMethods({
  _inherit: function(results, offset) {
    var index, length;
    length = results.length;
    if (offset >= length) {
      return;
    }
    index = offset - 1;
    while (++index < length) {
      this._results.push(results[index]);
    }
  },
  _resolve: function(parent, onFulfilled, onRejected) {
    assertType(parent, Promise);
    assertType(onFulfilled, Function.Maybe);
    assertType(onRejected, Function.Maybe);
    if (parent.isPending) {
      throw Error("The parent Promise must be resolved!");
    }
    if (!this.isPending) {
      return;
    }
    if (parent.isFulfilled) {
      if (onFulfilled) {
        return this._tryResolving(onFulfilled, parent._results);
      }
      return this._fulfill(parent._results[0]);
    }
    if (onRejected) {
      return this._tryResolving(onRejected, parent._results);
    }
    return this._reject(parent._results[0]);
  },
  _fulfill: function(value) {
    var length, queue;
    if (isType(value, Promise)) {
      throw Error("Cannot fulfill with a Promise as the result!");
    }
    if (!this.isPending) {
      return;
    }
    this._state = FULFILLED;
    this._results[0] = value;
    this._tracer.trace(this);
    length = (queue = this._queue).length;
    this._queue = null;
    if (!length) {
      return;
    }
    return immediate(this, function() {
      var index;
      index = -1;
      while (++index < length) {
        queue[index](this);
      }
    });
  },
  _reject: function(error) {
    var queue;
    assertType(error, Error.Kind);
    if (!this.isPending) {
      return;
    }
    this._state = REJECTED;
    this._results[0] = error;
    this._tracer.trace(this);
    queue = this._queue;
    this._queue = null;
    return immediate(this, function() {
      var index, length;
      index = -1;
      if (this._unhandled) {
        length = (queue = Promise._rejectFallbacks).length;
        while (++index < length) {
          queue[index](error, this);
        }
        return;
      }
      length = queue.length;
      while (++index < length) {
        queue[index](this);
      }
    });
  },
  _tryFulfilling: function(value) {
    if (isType(value, Promise)) {
      return value._always((function(_this) {
        return function() {
          _this._inherit(value._results, 1);
          return _this._resolve(value);
        };
      })(this));
    }
    if (value && isType(value.then, Function)) {
      this._defer(function(resolve, reject) {
        return value.then(resolve, reject);
      });
      return;
    }
    this._fulfill(value);
  },
  _tryResolving: function(resolver, args) {
    assertType(resolver, Function);
    return immediate(this, function() {
      var error, value;
      try {
        value = resolver.apply(null, args);
      } catch (error1) {
        error = error1;
        return this._reject(error);
      }
      if (value === this) {
        throw Error("Cannot resolve a Promise with itself!");
      }
      return this._tryFulfilling(value);
    });
  },
  _then: function(promise, onFulfilled, onRejected) {
    assertType(promise, Promise);
    assertType(onFulfilled, Function.Maybe);
    assertType(onRejected, Function.Maybe);
    this._tracer.trace(promise, this);
    this._always(function(parent) {
      return promise._resolve(parent, onFulfilled, onRejected);
    });
  },
  _always: function(onResolved) {
    assertType(onResolved, Function);
    this._unhandled = false;
    if (!this.isPending) {
      return immediate(this, function() {
        return onResolved(this);
      });
    }
    this._queue.push(onResolved);
  },
  _defer: function(resolver) {
    var reject, resolve;
    assertType(resolver, Function);
    if (resolver.length) {
      resolve = bind.method(this, "_tryFulfilling");
      if (resolver.length > 1) {
        reject = bind.method(this, "_reject");
      }
    }
    immediate(this, function() {
      var error;
      try {
        return resolver(resolve, reject);
      } catch (error1) {
        error = error1;
        return this._reject(error);
      }
    });
    return this;
  }
});

type.defineStatics({
  _rejectFallbacks: []
});

module.exports = Promise = type.build();
